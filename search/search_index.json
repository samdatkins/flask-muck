{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Flask-Muck","text":"<p>Flask-Muck is a batteries-included framework for automatically generating RESTful APIs with Create, Read,  Update and Delete (CRUD) endpoints in a Flask/SqlAlchemy application stack. </p> <p>With Flask-Muck you don't have to worry about the CRUD.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Automatic generation of CRUD endpoints.</li> <li>Built-in search, filter, sort and pagination when listing resources.</li> <li>Support for APIs with nested resources (i.e. /api/class//students). <li>Fully compatible with any other Flask method-based or class-based views. Mix &amp; match with your existing views.</li> <li>Pre and post callbacks configurable on all manipulation endpoints that allow for arbitrary logic before and after Create, Update or Delete operations.</li>"},{"location":"#license","title":"License","text":"<p>Flask-Muck is distributed under the MIT license.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#flaskmuckapiview","title":"FlaskMuckApiView","text":"<p>             Bases: <code>MethodView</code></p> Source code in <code>flask_muck/views.py</code> <pre><code>class FlaskMuckApiView(MethodView):\n    session: scoped_session\n    api_name: str\n    Model: SqlaModelType\n    parent: Optional[type[FlaskMuckApiView]] = None\n\n    ResponseSchema: type[Schema]\n    CreateSchema: Optional[type[Schema]] = None\n    UpdateSchema: Optional[type[Schema]] = None\n    PatchSchema: Optional[type[Schema]] = None\n    DeleteSchema: Optional[type[Schema]] = None\n    DetailSchema: Optional[type[Schema]] = None\n\n    pre_create_callbacks: list[type[FlaskMuckCallback]] = []\n    pre_update_callbacks: list[type[FlaskMuckCallback]] = []\n    pre_patch_callbacks: list[type[FlaskMuckCallback]] = []\n    pre_delete_callbacks: list[type[FlaskMuckCallback]] = []\n\n    post_create_callbacks: list[type[FlaskMuckCallback]] = []\n    post_update_callbacks: list[type[FlaskMuckCallback]] = []\n    post_patch_callbacks: list[type[FlaskMuckCallback]] = []\n    post_delete_callbacks: list[type[FlaskMuckCallback]] = []\n\n    searchable_columns: list[InstrumentedAttribute] = []\n    default_pagination_limit: int = 20\n    one_to_one_api: bool = False\n    allowed_methods: set[str] = {\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"}\n    operator_separator: str = \"__\"\n\n    @property\n    def query(self) -&gt; Query:\n        return self.session.query(self.Model)\n\n    def dispatch_request(self, **kwargs: Any) -&gt; ResponseReturnValue:\n        if request.method.lower() not in [m.lower() for m in self.allowed_methods]:\n            raise MethodNotAllowed\n        return super().dispatch_request(**kwargs)\n\n    def _execute_callbacks(\n        self,\n        resource: SqlaModel,\n        kwargs: JsonDict,\n        callback_type: CallbackType,\n    ) -&gt; None:\n        attr = f\"{callback_type.value}_{METHOD_OPERATION_MAP[request.method]}_callbacks\"\n        for callback in getattr(self, attr):\n            callback(resource, kwargs).execute()\n\n    def get_base_query_kwargs(self) -&gt; JsonDict:\n        \"\"\"Returns a set of base query args. This can be overridden to add additional kwargs to the base query.\n        Useful for multi-tenant apps that need to logically separate resources by client.\n        \"\"\"\n        return {}\n\n    def _get_base_query(self) -&gt; Query:\n        base_query: Query = self.query\n        base_query = base_query.filter(*get_query_filters_from_request_path(self, []))\n        if query_kwargs := self.get_base_query_kwargs():\n            base_query = base_query.filter_by(**query_kwargs)\n        return base_query\n\n    def _get_resource(cls, resource_id: Optional[ResourceId]) -&gt; SqlaModel:\n        query = cls._get_base_query()\n        if cls.one_to_one_api:\n            return query.one()\n        return query.filter(get_pk_column(cls.Model) == resource_id).one()\n\n    def _get_clean_filter_data(self, filters: str) -&gt; JsonDict:\n        try:\n            return json.loads(filters)\n        except JSONDecodeError:\n            raise BadRequest(f\"Filters [{filters}] is not valid json.\")\n\n    def _get_kwargs_from_request_payload(self) -&gt; JsonDict:\n        \"\"\"Creates the correct schema based on request method and returns a sanitized dictionary of kwargs from the\n        request json.\n        \"\"\"\n        if self.PatchSchema:\n            patch_schema = self.PatchSchema(partial=True)\n        elif self.UpdateSchema:\n            patch_schema = self.UpdateSchema(partial=True)\n        else:\n            None\n        schema_method_map = {\n            \"POST\": self.CreateSchema() if self.CreateSchema else None,\n            \"PUT\": self.UpdateSchema() if self.UpdateSchema else None,\n            \"PATCH\": patch_schema,\n            \"DELETE\": self.DeleteSchema() if self.DeleteSchema else None,\n        }\n        schema = schema_method_map[request.method]\n        if not schema:\n            raise NotImplementedError\n        kwargs = schema.load(request.json or {})\n        kwargs.update(self.get_base_query_kwargs())\n        return kwargs\n\n    @parser.use_kwargs(\n        {\n            \"limit\": fields.Integer(missing=None),\n            \"offset\": fields.Integer(missing=None),\n            \"filters\": fields.String(required=False, missing=None),\n            \"sort\": fields.String(required=False, missing=None),\n            \"search\": fields.String(required=False, missing=None),\n        },\n        location=\"querystring\",\n    )\n    def get(\n        self,\n        resource_id: Optional[ResourceId],\n        limit: Optional[int],\n        offset: Optional[int],\n        filters: Optional[str],\n        sort: Optional[str],\n        search: Optional[str],\n        **kwargs: Any,\n    ) -&gt; tuple[Union[JsonDict, list[JsonDict]], int]:\n        if resource_id or self.one_to_one_api:\n            resource = self._get_resource(resource_id)\n            if hasattr(self, \"DetailSchema\") and self.DetailSchema:\n                return self.DetailSchema().dump(resource)\n            else:\n                return self.ResponseSchema().dump(resource)\n        else:\n            query = self._get_base_query()\n            query_filters: list = []\n            join_models: set[SqlaModelType] = set()\n            if filters:\n                _filters = self._get_clean_filter_data(filters)\n                query_filters, _join_models = self._get_query_filters(_filters)\n                join_models.update(_join_models)\n\n            # Get order by from request\n            order_by = None\n            if sort:\n                order_by, _join_models = self._get_query_order_by(sort)\n                join_models.update(_join_models)\n\n            if search:\n                search_filter, _join_models = self._get_query_search_filter(search)\n                join_models.update(_join_models)\n                if search_filter is not None:\n                    query_filters.append(search_filter)\n\n            # Apply joins, filters and order by to the query.\n            for model in join_models:\n                if model != self.Model:\n                    query = query.outerjoin(model)\n            if query_filters:\n                query = query.filter(*query_filters)\n            if order_by is not None:\n                query = query.order_by(order_by)\n            query = query.distinct()\n\n            # If offset or limit were included in the query params return paginated response object else return a flat\n            # list of all items.\n            if offset or limit:\n                query_limit = limit or self.default_pagination_limit\n                query_offset = offset or 0\n                resources = query.limit(query_limit).offset(query_offset).all()\n                response_data = {\n                    \"limit\": query_limit,\n                    \"offset\": query_offset,\n                    \"total\": query.count(),\n                    \"items\": self.ResponseSchema(many=True).dump(resources),\n                }\n            else:\n                resources = query.all()\n                response_data = self.ResponseSchema(many=True).dump(resources)\n            return response_data, 200\n\n    def _create_resource(self, kwargs: JsonDict) -&gt; SqlaModel:\n        resource = self.Model(**kwargs)\n        self.session.add(resource)\n        self.session.flush()\n        return resource\n\n    def _update_resource(self, resource: SqlaModel, kwargs: JsonDict) -&gt; SqlaModel:\n        for attr, value in kwargs.items():\n            setattr(resource, attr, value)\n        return resource\n\n    def post(self) -&gt; tuple[JsonDict, int]:\n        if not self.CreateSchema:\n            raise NotImplementedError()\n        kwargs = self.get_base_query_kwargs()\n        data = self._get_kwargs_from_request_payload()\n        kwargs.update(data)\n        try:\n            resource = self._create_resource(kwargs)\n        except IntegrityError as e:\n            self.session.rollback()\n            raise Conflict(str(e))\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return self.ResponseSchema().dump(resource), 201\n\n    def put(self, resource_id: ResourceId, **kwargs: Any) -&gt; tuple[JsonDict, int]:\n        if not self.UpdateSchema:\n            raise NotImplementedError()\n        resource = self._get_resource(resource_id)\n        kwargs = self._get_kwargs_from_request_payload()\n        resource = self._update_resource(resource, kwargs)\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return self.ResponseSchema().dump(resource), 200\n\n    def patch(self, resource_id: ResourceId, **kwargs: Any) -&gt; tuple[JsonDict, int]:\n        if not self.PatchSchema:\n            raise NotImplementedError()\n        resource = self._get_resource(resource_id)\n        kwargs = self._get_kwargs_from_request_payload()\n        resource = self._update_resource(resource, kwargs)\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return self.ResponseSchema().dump(resource), 200\n\n    def delete(self, resource_id: ResourceId, **kwargs: Any) -&gt; tuple[str, int]:\n        resource = self._get_resource(resource_id)\n        kwargs = {}\n        if self.DeleteSchema:\n            kwargs = self._get_kwargs_from_request_payload()\n        self.session.delete(resource)\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return \"\", 204\n\n    def _get_query_filters(\n        self, filters: JsonDict\n    ) -&gt; tuple[list[BinaryExpression], set[SqlaModelType]]:\n        \"\"\"Translates a dictionary of column names and values into a list of SQLA query filters.\n        Also returns a list of models that should be joined to the base query.\n        \"\"\"\n        query_filters: list[BinaryExpression] = []\n        join_models: set[SqlaModelType] = set()\n        for column_name, value in filters.items():\n            # Get operator.\n            operator = None\n            if self.operator_separator in column_name:\n                column_name, operator = column_name.split(self.operator_separator)\n\n            # Handle nested filters.\n            if \".\" in column_name:\n                relationship_name, column_name = column_name.split(\".\")\n                field = getattr(self.Model, relationship_name, None)\n                if not field:\n                    raise BadRequest(\n                        f\"{column_name} is not a valid filter field. The relationship does not exist.\"\n                    )\n                _Model = field.property.mapper.class_\n                join_models.add(_Model)\n            else:\n                _Model = self.Model\n\n            if not (column := getattr(_Model, column_name, None)):\n                raise BadRequest(f\"{column_name} is not a valid filter field.\")\n\n            if operator == \"gt\":\n                _filter = column &gt; value\n            elif operator == \"gte\":\n                _filter = column &gt;= value\n            elif operator == \"lt\":\n                _filter = column &lt; value\n            elif operator == \"lte\":\n                _filter = column &lt;= value\n            elif operator == \"ne\":\n                _filter = column != value\n            elif operator == \"in\":\n                _filter = column.in_(value)\n            elif operator == \"not_in\":\n                _filter = column.not_in(value)\n            else:\n                _filter = column == value\n            query_filters.append(_filter)\n        return query_filters, join_models\n\n    def _get_query_order_by(\n        self, sort: str\n    ) -&gt; tuple[Optional[UnaryExpression], set[SqlaModelType]]:\n        if self.operator_separator in sort:\n            column_name, direction = sort.split(self.operator_separator)\n        else:\n            column_name, direction = sort, \"asc\"\n\n        # Handle nested fields.\n        join_models = set()\n        if \".\" in column_name:\n            relationship_name, column_name = column_name.split(\".\")\n            field = getattr(self.Model, relationship_name, None)\n            if not field:\n                raise BadRequest(f\"{column_name} is not a valid sort field.\")\n            _Model = field.property.mapper.class_\n            join_models.add(_Model)\n        else:\n            _Model = self.Model\n\n        if hasattr(_Model, column_name):\n            column = getattr(_Model, column_name)\n            if direction == \"asc\":\n                order_by = column.asc()\n            elif direction == \"desc\":\n                order_by = column.desc()\n            else:\n                raise BadRequest(\n                    f\"Invalid sort direction: {direction}. Must asc or desc\"\n                )\n        else:\n            raise BadRequest(f\"{column_name} is not a valid sort field.\")\n        return order_by, join_models\n\n    def _get_query_search_filter(\n        self, search_string: str\n    ) -&gt; tuple[Optional[BooleanClauseList], set[SqlaModelType]]:\n        \"\"\"Returns SQLA full text search filters for the search_term provided.\"\"\"\n        if not self.searchable_columns:\n            raise BadRequest(\"Search is not supported on this endpoint.\")\n        searches = []\n        join_models = set()\n        for column in self.searchable_columns:\n            join_models.add(column.parent.class_)\n            searches.append(column.ilike(f\"%{search_string}%\"))\n        if len(searches) == 1:\n            return searches[0], join_models\n        else:\n            return or_(*searches), join_models\n\n    @classmethod\n    def add_rules_to_blueprint(cls, blueprint: Blueprint) -&gt; None:\n        \"\"\"Adds CRUD endpoints to a blueprint.\"\"\"\n        url_rule = get_url_rule(cls, None)\n        api_view = cls.as_view(f\"{cls.api_name}_api\")\n\n        # In the special case that this API represents a ONE-TO-ONE relationship, use / for all methods.\n        if cls.one_to_one_api:\n            blueprint.add_url_rule(\n                url_rule,\n                defaults={\"resource_id\": None},\n                view_func=api_view,\n                methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n            )\n\n        else:\n            # Create endpoint - POST on /\n            blueprint.add_url_rule(url_rule, view_func=api_view, methods=[\"POST\"])\n\n            # List endpoint - GET on /\n            blueprint.add_url_rule(\n                url_rule,\n                defaults={\"resource_id\": None},\n                view_func=api_view,\n                methods=[\"GET\"],\n            )\n\n            # Detail, Update, Patch, Delete endpoints - GET, PUT, PATCH, DELETE on /&lt;resource_id&gt;\n            blueprint.add_url_rule(\n                f\"{url_rule}/&lt;{get_pk_type(cls.Model)}:resource_id&gt;/\",\n                view_func=api_view,\n                methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n            )\n</code></pre>"},{"location":"api_reference/#flask_muck.FlaskMuckApiView.add_rules_to_blueprint","title":"<code>add_rules_to_blueprint(blueprint)</code>  <code>classmethod</code>","text":"<p>Adds CRUD endpoints to a blueprint.</p> Source code in <code>flask_muck/views.py</code> <pre><code>@classmethod\ndef add_rules_to_blueprint(cls, blueprint: Blueprint) -&gt; None:\n    \"\"\"Adds CRUD endpoints to a blueprint.\"\"\"\n    url_rule = get_url_rule(cls, None)\n    api_view = cls.as_view(f\"{cls.api_name}_api\")\n\n    # In the special case that this API represents a ONE-TO-ONE relationship, use / for all methods.\n    if cls.one_to_one_api:\n        blueprint.add_url_rule(\n            url_rule,\n            defaults={\"resource_id\": None},\n            view_func=api_view,\n            methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n        )\n\n    else:\n        # Create endpoint - POST on /\n        blueprint.add_url_rule(url_rule, view_func=api_view, methods=[\"POST\"])\n\n        # List endpoint - GET on /\n        blueprint.add_url_rule(\n            url_rule,\n            defaults={\"resource_id\": None},\n            view_func=api_view,\n            methods=[\"GET\"],\n        )\n\n        # Detail, Update, Patch, Delete endpoints - GET, PUT, PATCH, DELETE on /&lt;resource_id&gt;\n        blueprint.add_url_rule(\n            f\"{url_rule}/&lt;{get_pk_type(cls.Model)}:resource_id&gt;/\",\n            view_func=api_view,\n            methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n        )\n</code></pre>"},{"location":"api_reference/#flask_muck.FlaskMuckApiView.get_base_query_kwargs","title":"<code>get_base_query_kwargs()</code>","text":"<p>Returns a set of base query args. This can be overridden to add additional kwargs to the base query. Useful for multi-tenant apps that need to logically separate resources by client.</p> Source code in <code>flask_muck/views.py</code> <pre><code>def get_base_query_kwargs(self) -&gt; JsonDict:\n    \"\"\"Returns a set of base query args. This can be overridden to add additional kwargs to the base query.\n    Useful for multi-tenant apps that need to logically separate resources by client.\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"api_usage/","title":"How to use the REST API","text":"<p>Now that a REST API has been created, it's time to use it. This section will cover each of the operations Flask-Muck generates with example curl commands and descriptions.</p> <p>For the purposes of this example, assume we have created a ToDo list application. The API for working with Todo list items  is below.</p> <pre><code>class TodoApiView(FlaskMuckApiView):\n    session = db.session\n    api_name = \"todos\"\n    Model = TodoModel\n    ResponseSchema = TodoSchema\n    CreateSchema = TodoSchema\n    PatchSchema = TodoSchema\n    UpdateSchema = TodoSchema\n    searchable_columns = [TodoModel.text]\n</code></pre>"},{"location":"api_usage/#create-a-resource","title":"Create a resource","text":"<p>Creates of a single new resource. The <code>CreateSchema</code> is used to validate the request body and the <code>ResponseSchema</code> is used to serialize the newly created resource in the response body.</p> Example cURL Command<pre><code>curl -X POST --location \"http://127.0.0.1:5000/api/v1/todos\" \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n            \\\"text\\\": \\\"Pick up bread and milk.\\\"\n        }\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Pick up bread and milk.\",\n    \"completed\": false\n}\n</code></pre> </p>"},{"location":"api_usage/#list-all-resources-flat","title":"List all resources (flat)","text":"<p>Returns a flat list of all resources. The <code>ResponseSchema</code> is used to serialize the resources in the response body.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos\" \\\n    -d \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 1,\n        \"text\": \"Pick up bread and milk.\",\n        \"completed\": false\n    },\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p>"},{"location":"api_usage/#list-all-resources-paginated","title":"List all resources (paginated)","text":"<p>Returns a paginated set of resources. The <code>ResponseSchema</code> is used to serialize the resources in the response body. To  trigger the paginated response, the <code>limit</code> and/or <code>offset</code> querystring parameters must be provided.</p> Example cURL Command<pre><code>cURL -X GET --location \"http://127.0.0.1:5000/api/v1/todos?limit=2&amp;offset=1\" \\\n    -d \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"items\": [\n        {\n            \"id\": 2,\n            \"text\": \"Take out garbage.\",\n            \"completed\": false\n        },\n        {\n            \"id\": 3,\n            \"text\": \"Paint the fence.\",\n            \"completed\": false\n        }\n    ],\n    \"limit\": 2,\n    \"offset\": 1,\n    \"total\": 2\n}\n</code></pre> </p>"},{"location":"api_usage/#search-all-resources","title":"Search all resources","text":"<p>Returns a list of resources that match the provided search query. The search term is matched against the <code>searchable_columns</code> using an ILIKE query. The <code>ResponseSchema</code> is used to serialize the resources in the response body.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?search=garbage\" \\\n    -d \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p>"},{"location":"api_usage/#filter-all-resources","title":"Filter all resources","text":"<p>Returns a list of resources that match the provided filters. The <code>filters</code> querystring parameter is a JSON encoded object that is used to filter the resources. Filtering can be done against any column on the model and also supports filtering against relationships using dot notation. Operators are supported using the following syntax: <code>&lt;column&gt;__&lt;operator&gt;</code> to do  more complex filtering. A list of available operators is in the table directly below. The <code>ResponseSchema</code> is used to serialize the resources in the response body.</p> Operator Description None Equals <code>ne</code> Not Equals <code>lt</code> Less Than <code>lte</code> Less Than or Equal To <code>gt</code> Greater Than <code>gte</code> Greater Than or Equal To <code>in</code> In <code>not_in</code> Not In <p>An example of a complex filter using operators and relationships is <code>filters={\"list.priority__gte\": 5}</code>. This would filter the ToDo items whose related list has a priority greater than or equal to 5.</p> Example <p>cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?filters=%7B%22text%22%3A+%22Take+out+garbage+again%22%7D\" \\\n    -d \"Accept: application/json\"\n</code></pre> querystring urldecodes to <code>filters={\"text\": \"Take out garbage again\"}</code> </p> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p>"},{"location":"api_usage/#sort-all-resources","title":"Sort all resources","text":"<p>Return a list of resources sorted by the provided column. Using dot notation you can sort by a related column.  Use the <code>asc</code> or <code>desc</code> operator suffix to specify the sort order. The <code>ResponseSchema</code> is used to serialize the  resources in the response body. Default sort direction is dependent on your datbabase.A complex example of sorting by a  related column is <code>sort=list.priority__desc</code>.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?sort=text__desc\" \\\n    -d \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    },\n    {\n        \"id\": 1,\n        \"text\": \"Pick up bread and milk.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p> <p>Tip</p> <p>Any combination of the search, filter, sort, and pagination querystring parameters can be used together.</p>"},{"location":"api_usage/#fetch-a-resource","title":"Fetch a resource","text":"<p>Return a single resource by its primary key. The <code>DetailSchema</code> is used to serialize the response. If <code>DetailSchema</code>  does not exist Flask-Muck falls back to using the <code>ResponseSchema</code>.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos/1\" \\\n    -d \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Pick up bread and milk.\",\n    \"completed\": false\n}\n</code></pre> </p>"},{"location":"api_usage/#update-a-resource","title":"Update a resource","text":"<p>Update a single resource by its primary key. The <code>UpdateSchema</code> is used to validate the request body. The update endpoint  adheres to PUT semantics and is intended to replace the entire resource with the provided data.  If you want to do a partial update use the PATCH endpoint. The <code>ResponseSchema</code> is used to serialize the response.</p> Example cURL Command<pre><code>curl -X PUT --location \"http://127.0.0.1:5000/api/v1/todos/1\" \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n            \\\"text\\\": \\\"Updated todo item\\\",\n            \\\"completed\\\": true \n        }\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Updated todo item\",\n    \"completed\": true\n}\n</code></pre> </p>"},{"location":"api_usage/#patch-a-resource","title":"Patch a resource","text":"<p>Update a single resource by its primary key. The patch endpoint adheres to PATCH semantics and is intended to partially  update the resource with the provided data. If you want to do a full update use the PUT endpoint. The <code>PatchSchema</code> is used to validate the request body, if the schema does not exist Flask-Muck falls back to using the <code>UpdateSchema</code>.  Regardless of which schema is used the schema is initialized with <code>partial=True</code> which allows for partial updates. The <code>ResponseSchema</code> is used to serialize the response.</p> Example cURL Command<pre><code>curl -X PATCH --location \"http://127.0.0.1:5000/api/v1/todos/1\" \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n            \\\"completed\\\": true \n        }\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Pick up bread and milk.\",\n    \"completed\": true\n}\n</code></pre> </p>"},{"location":"api_usage/#delete-a-resource","title":"Delete a resource","text":"<p>Delete a single resource by its primary key. The <code>ResponseSchema</code> is used to serialize the response. Optionally, the <code>DeleteSchema</code> can be used to validate the request body in the case that additional custom logic occurs during a delete operation. If the schema does not exist the resource is deleted. The response is always empty.</p> Example <p>cURL Command<pre><code>curl -X DELETE --location \"http://127.0.0.1:5000/api/v1/todos/1\"\n</code></pre> </p>"},{"location":"callbacks/","title":"Pre/Post Callbacks","text":"<p>At some point in the evolution of most projects simple CRUD actions will not be enough. APIs will likely need to do  complex validation possibly requiring checks against external services. Or additional actions will need to occur after the CRUD operations such as sending emails, starting asynchronous background tasks, adding audit information, etc. </p> <p>Flask-Muck includes an easy-to-use callback system that allows you to define functions and execute them before or after  any CRUD operation. </p> <p>The functions are defined by creating <code>FlaskMuckCallBack</code> subclasses. a <code>FlaskMuckCallback</code> has a single method that  must be overriden, <code>execute</code>, that takes no arguments and returns <code>None</code>. Simply override this functions with  any logic that needs to occur before or after a CRUD operation. </p> <p>The <code>execute</code> method has access to two attributes, <code>self.resource</code> and <code>self.kwargs</code>. </p> Attribute Description resource SqlAlchemy model instance affected by the operation. kwargs Dictionary of keyword arguments used to execute the CRUD operation. Union of kwargs sent in the json payload and any returned by the <code>get_base_query_kwargs</code> method. You can read more about <code>get_base_query_kwargs</code> in the Supporting Logical Data Separation (Multi-tenancy) section. <p>The <code>FlaskMuckCallBack</code> class is then added to a pre or post callbacks lists on a <code>FlaskMuckApiView</code>.  There is a class variable for the pre and post callback list for each CRUD operation. The name of the class variables  follow this naming convention, <code>&lt;pre_or_post\\&gt;_&lt;operation\\&gt;_callbacks</code>.</p> <pre><code>import logging\n\nfrom flask import request\nfrom flask_muck import FlaskMuckCallback, FlaskMuckApiView\n\n\nclass LogCallback(FlaskMuckCallback):\n    def execute(self) -&gt; None:\n        logging.info(f\"{request.method=} {self.resource=} {self.kwargs=}\")\n\nclass MyApiView(FlaskMuckApiView):\n    ...\n    post_create_callbacks = [LogCallback]\n    post_patch_callbacks = [LogCallback]\n    post_update_callbacks = [LogCallback]\n    post_delete_callbacks = [LogCallback]\n</code></pre> <p>Tip</p> <p>Any number of callbacks can be added to a callbacks list. The callbacks are executed serially and in the order.  Keep this in mind if the effects of some callbacks may influence others.</p>"},{"location":"callbacks/#example-usage","title":"Example Usage","text":"<p>Note</p> <p>This example expands on the example in the quickstart. If you have not read through the quickstart this will make more sense if you do.</p> <p>This scenario represents an app that tracks teachers and students. The requirements for the app are:</p> <ul> <li>Teachers' credentials must to be verified against an external service before they can be added.</li> <li>All modification actions need be added to the audit log for compliance.</li> <li>When a student or teacher is added they will be sent a welcome email.</li> </ul> myapp/models.py<pre><code>from myapp import db\n\nclass Teacher(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    email = db.Column(db.String, nullable=False)\n    years_teaching = db.Column(db.Integer)\n\nclass Student(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    email = db.Column(db.String, nullable=False)\n    parent_id = db.Column(db.ForeignKey(Teacher.id))\n    parent = db.relationship(Teacher)\n</code></pre> myapp/callbacks.py<pre><code>from flask import request\nfrom flask_login import current_user\nfrom flask_muck import FlaskMuckCallback\n\nfrom myapp.utils import add_audit_log#(1)!\nfrom myapp.utils import verify_teacher#(2)!\nfrom myapp.utils import send_welcome_email#(3)!\n\n\nclass VerifyTeacherCredentialsCallback(FlaskMuckCallback):\n    \"\"\"Check external service to verify a teacher has the correct teaching credentials.\"\"\"\n    def execute(self) -&gt; None:\n        verify_teacher(self.resource.name)\n\nclass AuditLogCallback(FlaskMuckCallback):\n    \"\"\"Adds a record to the audit log for SOC2 compliance.\"\"\"\n    def execute(self) -&gt; None:\n        add_audit_log(\n            user=current_user,\n            operation=request.method,\n            resource_type=type(self.resource),\n            resource_id=self.resource.id,\n            kwargs=self.kwargs,\n        )\n\nclass SendWelcomeEmailCallback(FlaskMuckCallback):\n    \"\"\"Sends a welcome email to newly created student or teacher.\"\"\"\n    def execute(self) -&gt; None:\n        send_welcome_email(name=self.resource.name, email=self.resource.email)\n</code></pre> <ol> <li><code>add_audit_log</code> is a function that adds a record to an audit used for compliance purposes.</li> <li><code>verify_teacher</code> is a function that makes a request to an external service and verifies they have adequate teacher's credentials. If they do not have the proper credentials an exception is raised.</li> <li><code>send_welcome_email</code> is a function that sends a welcome email to a student or teacher when they are added to the application.</li> </ol> myapp/schemas.py<pre><code>from marshmallow import Schema\nfrom marshmallow import fields as mf\n\n\nclass TeacherSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n    email = mf.String(required=True)\n    years_teaching = mf.Integer()\n\nclass StudentSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    email = mf.String(required=True)\n    name = mf.String(required=True)\n</code></pre> myapp/views.py<pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.auth.decorators import login_required\nfrom myapp.models import Teacher, Student\nfrom myapp.schemas import TeacherSchema, StudentSchema\nfrom myapp.callbacks import VerifyTeacherCredentialsCallback, AuditLogCallback, SendWelcomeEmailCallback\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]\n\n\nclass TeacherApiView(BaseApiView):\n    api_name = \"teachers\" \n    Model = Teacher \n    ResponseSchema = TeacherSchema \n    CreateSchema = TeacherSchema \n    PatchSchema = TeacherSchema \n    UpdateSchema = TeacherSchema \n\n    pre_create_callbacks = [VerifyTeacherCredentialsCallback]#(1)!\n    post_create_callbacks = [AuditLogCallback, SendWelcomeEmailCallback]#(2)!\n    post_patch_callbacks = [AuditLogCallback]\n    post_update_callbacks = [AuditLogCallback]\n    post_delete_callbacks = [AuditLogCallback]\n\n\nclass StudentApiView(BaseApiView):\n    api_name = \"student\" \n    Model = Student \n    parent = TeacherApiView\n    ResponseSchema = StudentSchema \n    CreateSchema = StudentSchema \n    PatchSchema = StudentSchema \n    UpdateSchema = StudentSchema\n\n    post_create_callbacks = [AuditLogCallback, SendWelcomeEmailCallback]\n    post_patch_callbacks = [AuditLogCallback]\n    post_update_callbacks = [AuditLogCallback]\n    post_delete_callbacks = [AuditLogCallback]\n</code></pre> <ol> <li>Using the <code>pre_create_callbacks</code> to validate the teacher before they are added.</li> <li>Note that you can add as many callbacks as you like. They will be executed serially and in order.</li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Configuration is handled entirely through setting class variables on the FlaskMuckApiViews. As noted in the quickstart you will likely have some class variable settings that will be shared by most or all of your view classes. It's advised to set up base classes to handle sharing configuration between views.</p>"},{"location":"configuration/#flaskmuckapiview-class-variables","title":"FlaskMuckApiView Class Variables","text":"Class Variable Description Required session <code>scoped_session</code> SqlAlchemy database session used to query and modify the resource. api_name <code>str</code> Name of the API. Used as the url path appended to your Flask Blueprint. Model <code>SqlaModelType</code> SqlAlchemy Model used to make queries. ResponseSchema <code>type[Schema]</code> Marshmallow schema used to serialize the resource returned by any of the views. decorators <code>list[Callable]</code> List of decorators to apply to all views in the API. This is inherited functionality built into Flask's class based views. parent <code>Optional[type[FlaskMuckApiView]]</code> If set, this API becomes a nested resource API. For more information on nested APIs see the documentation. CreateSchema <code>Optional[type[Schema]]</code> Marshmallow schema used to validate the POST request JSON payload sent to create a resource. UpdateSchema <code>Optional[type[Schema]]</code> Marshmallow schema used to validate the PUT request JSON payload sent to update a resource. PatchSchema <code>Optional[type[Schema]]</code> Marshmallow schema used to validate the PATCH request JSON payload sent to patch a resource. DeleteSchema <code>Optional[type[Schema]]</code> Marshmallow schema used to validate the DELETE request JSON payload sent to create a resource. Optional. DetailSchema <code>Optional[type[Schema]]</code> Optional Marshmallow schema used to serialize the resource returned by the GET /&lt;api_name&gt;/&lt;ID&gt;/ endpoint. If this schema is not set the ResponseSchema is used. pre_create_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is created. Ideal for validation. pre_update_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is updated. Ideal for validation. pre_patch_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is patched. Ideal for validation. pre_delete_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is deleted. Ideal for validation. post_create_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is created. Useful for activities such as notifications. Called post commit. post_update_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is updated. Useful for activities such as notifications. Called post commit. post_patch_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is patched. Useful for activities such as notifications. Called post commit. post_delete_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is deleted. Useful for activities such as notifications. Called post commit. searchable_columns <code>list[InstrumentedAttribute]</code> List of Model columns that will be queried using an \"ILIKE\" statement when the <code>search=</code> query param is used on the GET /resource/ endpoint. default_pagination_limit <code>int</code> Default pagination limit when retrieving paginated results on the GET /&lt;api_name&gt;/ endpoint. Default is 20. one_to_one_api <code>bool</code> If True this API is treated as a one-to-one relationship and the GET /&lt;api_name&gt;/ endpoint will return a single resource. Generally used in combination with the <code>parent</code> setting. allowed_methods <code>set[str]</code> Set of allowed HTTP methods for this API. Default is <code>{\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"}</code>. This setting is used to control which actions are available for this resource. Not including a method affects which routes will be registered to a Flask Blueprint. operator_separator <code>str</code> Separator used when assigning operators to search or filter query parameters in the GET /&lt;api_name&gt;/ endpoint. Default is <code>\"__\"</code>."},{"location":"configuration/#base-class-example","title":"Base Class Example","text":"<p>Let's say you have an API with the following requirements for all views:</p> <ul> <li>Has authentication decorator.</li> <li>Has permission checking decorator.</li> <li>Does not allow patches.</li> <li>Uses \"|\" as the operator separator for filters.</li> <li>Uses the standard database session.</li> </ul> <p>The best way to handle this is to create a base API view that all other API views inherit from.</p> Base Class<pre><code>class BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required, permission_required]\n    allowed_methods = {\"GET\", \"POST\", \"PUT\", \"DELETE\"}\n    operator_separator = \"|\"\n</code></pre> Concrete Class<pre><code>class TurtleApiView(BaseApiView):#(1)!\n    api_name = 'turtles'\n    Model = Turtle\n    ...#(2)!\n</code></pre> <ol> <li>Concrete view inherits from the BaseApiView and ingerits all of its configuration.</li> <li>Remainder of class variables are configured as normal.</li> </ol>"},{"location":"escape_hatches/","title":"Escape Hatches","text":"<p>Flask-Muck is not intended to handle 100% of your API endpoints. It does one job and does it well, creating standard CRUD  endpoints. Inevitably you will need to step out of Flask-Muck's logic for more specific or targeted endpoints. Flask-Muck is designed to be mixed and matched with any other Flask method-based or class-based views.</p> <p>This chapter covers the various \"escape hatches\" that allow you to step outside Flask-Muck's logic and add your own custom endpoints to the API or change the internals of how Flask-Muck handles operations.</p>"},{"location":"escape_hatches/#using-allowed_methods-settings-to-omit-endpoints","title":"Using <code>allowed_methods</code> settings to omit endpoint(s).","text":"<p>The <code>allowed_methods</code> class variable allows you to omit endpoints from being added to your API by Flask-Muck. This is useful if you want to add your own custom endpoint for a specific HTTP method. A common example is an API whose create operation  is very complex but the rest of the CRUD operations are simple. </p> <pre><code>blueprint = Blueprint(\"api\", __name__, url_prefix=\"/api/\")\n\nclass MyModelApiView(FlaskMuckApiView):\n    api_name = \"my-model\"\n    session = db.session\n    Model = MyModel\n    ResponseSchema = MyModelSchema\n    CreateSchema = MyModelSchema\n    PatchSchema = MyModelSchema\n    UpdateSchema = MyModelSchema\n    searchable_columns = [MyModel.name]\n    allowed_methods = {\"GET\", \"PATCH\", \"PUT\", \"DELETE\"}#(1)!\n\nMyModelApiView.add_rules_to_blueprint(blueprint)\n\n@blueprint.route(\"/api/v1/my-model\", methods=[\"POST\"])\ndef create_my_model():\n    ...#(2)!\n</code></pre> <ol> <li>Notice the \"POST\" method is omitted from the <code>allowed_methods</code> set. This will prevent Flask-Muck from adding a create endpoint.</li> <li>Do your one-off create logic here.</li> </ol> <p>Additionally the <code>allowed_methods</code> setting can be used to create read-only APIs - <code>allowed_methods = {\"GET\"}</code>.</p>"},{"location":"escape_hatches/#overriding-create-and-update-logic","title":"Overriding create and update logic.","text":"<p>There are two simple FlaskMuckApiView methods that handle creating (POST) and updating (PUT/PATCH) resources.</p> <pre><code>    def _create_resource(self, kwargs: JsonDict) -&gt; SqlaModel:\n        resource = self.Model(**kwargs)\n        self.session.add(resource)\n        self.session.flush()\n        return resource\n\n    def _update_resource(self, resource: SqlaModel, kwargs: JsonDict) -&gt; SqlaModel:\n        for attr, value in kwargs.items():\n            setattr(resource, attr, value)\n        return resource\n</code></pre> <p>These methods are designed to be override seams that allow you to customize how resources are created and updated. For example, let's say all of your models have a <code>create</code> classmethod that should be used to create new resources. You could override the <code>_create_resource</code> method to use the <code>create</code> classmethod instead of the default constructor.</p> <pre><code>    def _create_resource(self, kwargs: JsonDict) -&gt; SqlaModel:\n        resource = self.Model.create(**kwargs)\n        return resource\n</code></pre>"},{"location":"escape_hatches/#customizing-keyword-arguments-passed-to-all-operations","title":"Customizing keyword arguments passed to all operations.","text":"<p>In many cases you will want to customize the keyword arguments passed to all operations. FlaskMuckApiView provides a  <code>get_base_query_kwargs</code> method that can be overridden to customize the keyword arguments passed to all operations.</p> <pre><code>    def get_base_query_kwargs(self) -&gt; JsonDict:\n        return {}\n</code></pre> <p>Let's say you have a <code>deleted</code> column that is used to soft-delete resources. You could override <code>get_base_query_kwargs</code> to always filter out deleted resources and make sure that any new or updated resources are not marked as deleted.</p> <pre><code>    def get_base_query_kwargs(self) -&gt; JsonDict:\n        return {\"deleted\": False}\n</code></pre> <p>You can find a deeper example using this method in the Supporting Logical Data Separation (Multi-tenancy) chapter.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#pip","title":"pip","text":"<p>Flask-Muck is currently only available on PyPi and can be installed with pip.</p> <p><code>pip install flask-muck</code></p>"},{"location":"logical_separation/","title":"Supporting Logical Data Separation (Multi-tenancy)","text":"<p>A common architecture in web applications is multi-tenancy through logical separation. The FlaskMuckApiView includes  a method, <code>get_base_query_kwargs</code>, that can be overridden to generate a set of arguments that will be passed to all queries.  This allows you to filter resources to only those that should be available to a user and prevent resources from leaking  between tenants. </p> <p>The <code>get_base_query_kwargs</code> should return a dictionary of keyword arguments. Those kwargs will be applied to CRUD operations at the SqlAlchemy level. For example the GET /&lt;resource&gt;/ endpoint will generate  the query <code>Model.query.filter_by(**get_base_query_kwargs()).all()</code> instead of <code>Model.query.all()</code>. The keyword arguments will also be applied when creating or updating a model.</p> <pre><code>from flask_login import current_user\nfrom flask_muck import FlaskMuckApiView\n\n\nclass MyApiView(FlaskMuckApiView):\n    ...\n\n    def get_base_query_kwargs(self):\n        return {\"organization_id\": current_user.organization_id}#(1)!\n</code></pre> <ol> <li>Assumes the resource has the <code>organization_id</code> column and it will be filtered by the current user's organization id.</li> </ol>"},{"location":"logical_separation/#example-usage","title":"Example Usage","text":"<p>Note</p> <p>This example expands on the example in the quickstart. If you have not read through the quickstart this will make more sense if you do.</p> <p>Assume we have a customer support platform where each user belongs to a single organization. Nearly all resources in the  application are associated with an organization and when the user accesses them they should only see resources in the same organization as them.</p> <p>The SqlAlchemy models will look something like this.</p> myapp/models.py<pre><code>from myapp import db\n\nclass Organization(db.model):\n    \"\"\"Customer support organization that contains users and support tickets.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    name = db.Column(db.String, nullable=False)\n\nclass User(db.Model):\n    \"\"\"User that is responsible for responding to support tickets in their organization.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    email = db.Column(db.String, nullable=False)\n    organization_id = db.Column(db.ForeignKey(Organization.id))\n    organization = db.relationship(Organization)\n\nclass SupportTicket(db.Model):\n    \"\"\"Support ticket submitted for an organization.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    order_number = db.Column(db.Integer, nullable=False)\n    organization_id = db.Column(db.ForeignKey(Organization.id))\n    organization = db.relationship(Organization)\n\nclass NewsfeedItem(db.Model):\n    \"\"\"A newsfeed item with information about the platform (i.e. release notes). Available to all users regardless of \n    organization.\n    \"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    text = db.Column(db.String, nullable=False)\n</code></pre> <p>Since we'll have views that need to be filtered by organization and others that do not two base classes will be created.</p> myapp/baseviews.py<pre><code>from flask_login import login_required, current_user\nfrom flask_muck import FlaskMuckApiView\n\nfrom myapp import db\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]#(1)!\n\nclass OrganizationResourceApiView(BaseApiView):\n    def get_base_query_kwargs(self):\n        return {\"organization_id\": current_user.organization_id}#(2)!\n</code></pre> <ol> <li>Flask-Login is used to enforce user authentication by adding the login_required decorator.</li> <li>Flask-Login is used to give the views access to the current user and therefore the current organization to filter by.</li> </ol> <p>Now all we need to do is choose the correct base view class based on whether the resource should be filtered by the current  user's organization.</p> views.py<pre><code>from myapp.baseviews import BaseApiView, OrganizationResourceApiView\nfrom myapp.models import SupportTicket, NewsfeedItem\n\nclass SupportTicketsApiView(OrganizationResourceApiView):\n    Model = SupportTicket\n    ...#(1)!\n\nclass NewsfeedItemApiview(BaseApiView):\n    Model = NewsfeedItem\n    ...#(2)!\n</code></pre> <ol> <li>Remainder of the SupportTicketsApiView configuration goes here.</li> <li>Remainder of the NewsfeedItemApiview configuration goes here.</li> </ol>"},{"location":"nesting_apis/","title":"Nesting Resource APIs","text":"<p>Nesting hierarchical resources in a REST API is a common practice. Flask-Muck provides out-of-the-box support for  generating nested APIs if the SqlAlchemy models are related by a basic foreign key relationship. Nested APIs automatically handle filtering child resources and  supplying the parent id as input during the Create operation.</p> <p>Creating the nested relationship is as simple as setting the <code>parent</code> class variable of a FlaskMuckApiView to another  FlaskMuckApiView who's <code>Model</code> has a valid foreign key relationship. </p> <pre><code>from flask import Blueprint\n\nfrom flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.models import Parent, Child\nfrom myapp.schemas import ParentSchema, ChildSchema\n\nclass ParentApiView(FlaskMuckApiView):\n    api_name = \"parents\"\n    session = db.session\n    Model = Parent\n    ResponseSchema = ParentSchema\n    CreateSchema = Parentchema\n    PatchSchema = Parentchema\n    UpdateSchema = ParentSchema\n\nclass ChildApiView(FlaskMuckApiView):\n    api_name = \"children\"\n    session = db.session\n    parent = ParentApiView#(1)!\n    Model = Child#(2)!\n    ResponseSchema = ChildSchema\n    CreateSchema = ChildSchema\n    PatchSchema = ChildSchema\n    UpdateSchema = ChildSchema\n\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api/\")\nParentApiView.add_rules_to_blueprint(blueprint)\nChildApiView.add_rules_to_blueprint(blueprint)\n</code></pre> <ol> <li>Setting the <code>parent</code> class variable to another FlaskMuckApiView is all that is needed to set up nesting.</li> <li>The <code>Child</code> model must have a foreign key column that references the <code>Parent</code> model.</li> </ol> <p>This produces the following nested api resources.</p> URL Path Method Description /api/parents/ GET List all parents /api/parents/ POST Create a parent /api/parents/&lt;ID&gt;/ GET Fetch a parent /api/parents/&lt;ID&gt;/ PUT Update a parent /api/parents/&lt;ID&gt;/ PATCH Patch a parent /api/parents/&lt;ID&gt;/ DELETE Delete a parent /api/parents/&lt;ID&gt;/children/ GET List all of a parent's children /api/parents/&lt;ID&gt;/children/ POST Create a child foreign keyed to a parent. /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ GET Fetch a child /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ PUT Update a child /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ PATCH Patch a child /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ DELETE Delete a child <p>Tip</p> <p>Nesting APIs works recursively so you don't have to stop at one level of nesting. </p> <p>Warning</p> <p>If your models are not using standard integer or UUID primary keys nested APIs may not work correctly.</p>"},{"location":"nesting_apis/#usage-example","title":"Usage Example","text":"<p>Note</p> <p>This example expands on the example in the quickstart. If you have not read through the quickstart this will make more sense if you do.</p> <p>Let's say that we wanted to add a nested endpoint to our teacher detail endpoint from the quickstart that would allow us to work with all of a teacher's students.</p> <p>Below are the models, schemas and views we would need.</p> myapp/models.py<pre><code>from myapp import db\n\nclass Teacher(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    years_teaching = db.Column(db.Integer)\n\nclass Student(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    parent_id = db.Column(db.ForeignKey(Teacher.id))\n    parent = db.relationship(Teacher)\n</code></pre> myapp/schemas.py<pre><code>from marshmallow import Schema\nfrom marshmallow import fields as mf\n\n\nclass TeacherSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n    years_teaching = mf.Integer()\n\nclass StudentSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n</code></pre> myapp/views.py<pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.auth.decorators import login_required\nfrom myapp.models import Teacher, Student\nfrom myapp.schemas import TeacherSchema, StudentSchema\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]\n\n\nclass TeacherApiView(BaseApiView):\n    api_name = \"teachers\" \n    Model = Teacher \n    ResponseSchema = TeacherSchema \n    CreateSchema = TeacherSchema \n    PatchSchema = TeacherSchema \n    UpdateSchema = TeacherSchema \n    searchable_columns = [Teacher.name] \n\n\nclass StudentApiView(BaseApiView):\n    api_name = \"student\" \n    Model = Student \n    parent = TeacherApiView\n    ResponseSchema = StudentSchema \n    CreateSchema = StudentSchema \n    PatchSchema = StudentSchema \n    UpdateSchema = StudentSchema \n    searchable_columns = [Student.name]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Flask-Muck provides standard REST APIs for resources in your Flask/SqlAlchemy application. This  is accomplishing by creating subclasses of the FlaskMuckApiView and configuring them by setting a series of class variables.</p> <p>The quick start guide will walk you through creating your first basic API. The subsequent chapters covering using the  APIs and configuring advanced features.</p>"},{"location":"quickstart/#define-a-base-view","title":"Define a base view","text":"<p>Flask-Muck works by subsclassing the FlaskMuckApiView and setting class variables on the concrete view classes. In almost  all projects there will be a basic set of class variables shared by all FlaskMuckApiView subclasses. The two most common  settings to be shared across all views is the database session used for committing changes and a set of  decorators that should be applied to all views.</p> <p>In this example a base class is defined with with the app's database session and authentication decorator set.</p> <p>Application using SqlAlchemy in Flask session setup: <pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp.database import db_session \nfrom myapp.auth.decorators import login_required\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db_session\n    decorators = [login_required]\n</code></pre></p> <p>Application using Flask-SqlAlchemy exension: <pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.auth.decorators import login_required\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]\n</code></pre></p> <p>Note</p> <p>For the remainder of this guide we'll assume usage of the Flask-SqlAlchemy extension.</p>"},{"location":"quickstart/#create-sqlalchemy-model","title":"Create SqlAlchemy Model","text":"<p>Flask-Muck requires the use of SqlAlchemy's declarative system. If you are not using the declarative system you will need to review those docs and re-evaluate whether Flask-Muck is the right choice. Explaining the full process of  creating and registering a SqlAlchemy model in your Flask app is outside the scope of this guide. The example code below shows the model class we will be creating an API for in the rest of the guide.</p> <pre><code>from myapp import db\n\nclass Teacher(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    years_teaching = db.Column(db.Integer)\n</code></pre>"},{"location":"quickstart/#create-input-and-response-marshmallow-schemas","title":"Create input and response Marshmallow schemas","text":"<p>Flask-Muck requires configuring Marshmallow schemas that will be used  to validate the payload data for the Create, Update, Patch and (optionally) Delete endpoints. Additionally a schema must  be supplied that will serialize the endpoint's resource in responses. In this example simple schema is defined that  can be re-used for all validation and serialization.</p> <pre><code>from marshmallow import Schema\nfrom marshmallow import fields as mf\n\n\nclass TeacherSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n    years_teaching = mf.Integer()\n</code></pre>"},{"location":"quickstart/#create-concrete-flaskmuckapiview","title":"Create concrete FlaskMuckApiView","text":"<p>Inherit from the project's base api view class and define the required class variables.</p> <pre><code>class TeacherApiView(BaseApiView):\n    api_name = \"teachers\" #(1)!\n    Model = Teacher #(2)!\n    ResponseSchema = TeacherSchema #(3)!\n    CreateSchema = TeacherSchema #(4)!\n    PatchSchema = TeacherSchema #(5)!\n    UpdateSchema = TeacherSchema #(6)!\n    searchable_columns = [Teacher.name] #(7)!\n</code></pre> <ol> <li>Name used as the url endpoint in the REST API.</li> <li>Model class that will be queried and updated by this API.</li> <li>Marshmallow schema used to serialize and Teachers returned by the API.</li> <li>Marshmallow schema used to validate payload data sent to the Create endpoint.</li> <li>Marshmallow schema used to validate payload data sent to the Patch endpoint.</li> <li>Marshmallow schema used to validate payload data sent to the Update endpoint.</li> <li>List of model columns that can be searched when listing Teachers using the API.</li> </ol>"},{"location":"quickstart/#add-url-rules-to-a-flask-blueprint","title":"Add URL rules to a Flask Blueprint.","text":"<p>The final step is to add the correct URL rules to an existing Flask Blueprint  object. A classmethod is included that handles adding all necessary rules to the given Blueprint.</p> <pre><code>from flask import Blueprint\n\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api/\")\nTeacherApiView.add_rules_to_blueprint(blueprint)\n</code></pre> <p>This produces the following views, a standard REST API!</p> URL Path Method Description /api/teachers/ GET List all teachers - querystring options available for sorting, filtering, searching and pagination /api/teachers/ POST Create a teacher /api/teachers/&lt;ID&gt;/ GET Fetch a single teacher /api/teachers/&lt;ID&gt;/ PUT Update a single teacher /api/teachers/&lt;ID&gt;/ PATCH Patch a single teacher /api/teachers/&lt;ID&gt;/ DELETE Delete a single teacher"}]}